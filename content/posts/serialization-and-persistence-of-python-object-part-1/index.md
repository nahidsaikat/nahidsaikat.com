---
title: "Serialization and Persistence of Python Object - Part 1"
date: "2024-04-02T20:23:29+06:00"
tags:
  - "Python"
description: "Python has some build-in modules that offers us to serialize and persists python object into a file and also allows us to de-serialize and use them from the file."
---

![Serialization and Persistence of Python Object](serialization-persistence.png "Serialization and Persistence of Python Object")
<center>
Image by <a href="https://pixabay.com/users/acatxio-20233758/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=7955446">AcatXIo</a> from <a href="https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=7955446">Pixabay</a>
</center>

<br>

Python has some build-in modules that offers us to serialize and persists python object into a file and also allows us to de-serialize and use them from the file. Those modules are handy and very useful while writing a python script. They give use a very nice interface that is easy to use and doesn't require much effort to learn them. This article will be a two part series. This is the first part and in this article we will discuss python's pickle and shelve module.

## Pickle module
Python's pickle module implements algorithm to serialize and de-serialize Python object structure. In pickling process Python object hierarchy are converted into byte stream and during unpickling the Python object hierarchy are reconstructed back from a byte stream, usually from a binary file or byte like object.

The data format used by pickle is specific to Python. Thus we cannot reconstruct the objects from non Python programs. There is a module [pickletools](https://docs.python.org/3/library/pickletools.html) that can be used to analyze data stream generated by pickle module. 6 protocols are used to pickling. The highest the protocol is the newer version of Python need to read the pickle produced.



To serialize an object hierarchy we need to call the `dumps` function. It will return the byte data stream. Similarly, to de-serialize the data stream need to call the `loads` function. We can use the functions `dump` and `load` that will write and read the data strem in file.

Here is an example to write in a file,

```python
import pickle

class Employee:
    def __init__(self, name, department):
        self.name = name
        self.department = department
    
    def get_department(self):
        return f"Department is {self.department}"
    
    def __str__(self):
        return f"Name: {self.name}, Department: {self.department}"

data = {
    'a': [1, 2.0, 3+4j],
    'b': ("string value", b"byte string"),
    'c': {True, False, None},
    'emp1': Employee("Kawsar Ahmed", "Engineering")
}

with open('data.pickle', 'wb') as file:
    pickle.dump(data, file, pickle.HIGHEST_PROTOCOL)
```

To read from the file,

```python
import pickle

class Employee:
    def __init__(self, name, department):
        self.name = name
        self.department = department
    
    def get_department(self):
        return f"Department is {self.department}"
    
    def __str__(self):
        return f"Name: {self.name}, Department: {self.department}"

with open('data.pickle', 'rb') as f:
    data = pickle.load(f)

print(data["a"])
print(data["b"])
print(data["c"])

emp1 = data["emp1"]
print(emp1)
print(emp1.get_department())

# [1, 2.0, (3+4j)]
# ('string value', b'byte string')
# {False, True, None}
# Name: Kawsar Ahmed, Department: Engineering
# Department is Engineering
```

From the Python documentation the following types can be pickled:

* built-in constants (None, True, False, Ellipsis, and NotImplemented);
* integers, floating-point numbers, complex numbers;
* strings, bytes, bytearrays;
* tuples, lists, sets, and dictionaries containing only picklable objects;
* functions (built-in and user-defined) accessible from the top level of a module (using def, not lambda);
* classes accessible from the top level of a module;
* instances of such classes whose the result of calling __getstate__() is picklable.

When tried to pickle an unpickable objects it will raise `PicklingError` exception.

One caution to note is that do not load and unpickle data from the internet unless you trust the source. There is no way to know what is inside the pickled data untill running it. If it contains a shell command then it can have access to your computer.

## Shelve module
Shelve is a persistent data storage that saves data on file. A shelf is a dictionary like object, that means we can use the similar methods with shelf objects that we usually use with dictionary object. Except copying, constructors and the merge operation  (`|` or `|=`) we can use all the dictionary methods and operations with shelf object. Shelve is very similar to dbm databases only the difference is that the values can be anything that the pickle module can handle. The keys are ordinary strings.

Shelve provides a context manager `shelve.open(filename)` that we can use to open a file and store data as key value pair. We can use `open` as function call as well but in that case we have to call `close` function manually to close a shelf. Under the hode shelve uses pickle module to serialize and de-serailize the objects. Let's see am example where we will store and read an integer, a string and a class instance using shelve.

Writing in the database file,
```python
import shelve

class Human:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def get_name(self):
        return f"The name is {self.name}"
    
    def __str__(self):
        return f"Name: {self.name}, Age: {self.age}"

with shelve.open("database") as db:
    db["a"] = "A string"
    db["b"] = 1234
    db["naim"] = Human("Naim", 10)
```

Reading from the database file,
```python
import shelve

class Human:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def get_name(self):
        return f"The name is {self.name}"
    
    def __str__(self):
        return f"Name: {self.name}, Age: {self.age}"

with shelve.open("database") as db:
    print(db["a"])
    print(db["b"])

    naim = db["naim"]
    print(naim)
    print(naim.get_name())

# A string
# 1234
# Name: Naim, Age: 10
# The name is Naim
```

One thing to note that while using a class object either from the database file or the pickle file, you have to make sure that it has access to the class definitation, otherwise it will through an error.

Click [this link](https://nahidsaikat.com/posts/serialization-and-persistence-of-python-object-part-2/) to read the second part of the article.

<hr>

##### References
* [pickle — Python object serialization](https://docs.python.org/3/library/pickle.html)
* [WHAT Is "Pickle" In Python?! (EXTREMELY Useful!)](https://youtu.be/6Q56r_fVqgw?si=NGb5SpMiytbtsQbt)
* [shelve — Python object persistence](https://docs.python.org/3/library/shelve.html)
* [Use Shelve For EFFECTIVE Persistent Data Storage In Python](https://youtu.be/lXafuQ9r8Lg?si=O-TQbxxd9aMyYeCo)
